> ##  浏览器存储：

### cookie:

由于http是无状态的，使用cookie使浏览器和服务器之间传递数据。

典型的应用场景有：记住密码，下次自动登录；购物车功能；记录用户浏览数据，进行商品（广告）推荐。

缺点：每个http请求都带了cookie，使得首部内容增加，影响带宽；不适合存储私人敏感信息；大小限制4kb左右。


### localStorage：

- 保存的数据长期存在，同源的本地数据可以共享。

- 大小为5M左右

- 仅在客户端使用，不和服务端进行通信

- 接口封装较好

  

### sessionStorage:

- 会话级别的浏览器存储
- 大小为5M左右
- 仅在客户端使用，不和服务端进行通信
- 接口封装较好

sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，**即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享**；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。



### IndexedDB

IndexedDB  用于客户端存储大量结构化数据**(包括文件和blobs)**。没有存储上限（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。



### 四者区别：

- 生命周期：cookie由服务器生成，设置过期时间即可；local除非被清理，否则一直存在；session页面关闭就清理；IndexDB除非被清理，否则一直存在
- 存储大小：4k 5M 5M 无限
- 与服务端通信：cookie每次都携带在header中，有性能影响；别的都不参与



> ##  浏览器缓存：

<https://github.com/ljianshu/Blog/issues/23>

缓存的作用是不言而喻的，能够极大的改善网页性能，提高用户体验。

### 缓存位置

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache



### 缓存过程

浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。

- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中



### 强缓存与协商缓存

通常浏览器缓存策略分为两种：**强缓存**和**协商缓存**，并且缓存策略都是通过设置 HTTP Header 来实现的。

浏览器在第一次请求发生后，再次请求时：

- 会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；
- 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容

强缓存：

- 强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200。

- 强缓存相关的header字段

  - **Expires **
  - **缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点**。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
    - **Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效**。`Expires: Wed, 22 Oct 2018 08:41:00 GMT`表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。
- **Cache-Control**：
  - 出现于 HTTP/1.1，优先级高于 Expires。Cache-Control是最重要的规则，主要用于控制网页缓存。比如当`Cache-Control:max-age=300`时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。
    - Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：public、private、no-cache、no-store、max-age、s-maxage、max-stale、min-fresh
  
### 协商缓存：

- 如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：`Last-Modified` 和 `ETag` 。

- 协商缓存相关的header字段

  - **Last-Modified 和 If-Modified-Since**
    - 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header
    - 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200

  - **ETag 和 If-None-Match**
    - Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。
  - 差别：
    - 首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。
    - 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
    - 第三在优先级上，服务器校验优先考虑Etag



### 默认缓存策略：

**如果什么缓存策略都没设置，那么浏览器会怎么处理？**
 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 `Date` 减去 `Last-Modified` 值的 10% 作为缓存时间。

 

### 实际场景应用缓存策略

- 频繁变动的资源  Cache-Control: no-cache
- 不常变化的资源  Cache-Control: max-age=31536000



### 用户行为影响

- 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
- 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
- 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control: no-cache`(为了兼容，还带了 `Pragma: no-cache`),服务器直接返回 200 和最新内容。





> ##  浏览器渲染：

目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。这里面大家最耳熟能详的可能就是 Webkit 内核了，Webkit 内核是当下浏览器世界真正的霸主。

### 浏览器渲染过程：

浏览器页面加载过程：

- 浏览器根据 DNS 服务器得到域名的 IP 地址
- 向这个 IP 的机器发送 HTTP 请求
- 服务器收到、处理并返回 HTTP 请求
- 浏览器得到返回内容

浏览器渲染过程：

- 构建DOM -> 构建CSSOM -> 构建渲染树 -> 布局 -> 绘制。

浏览器如果渲染过程中遇到JS文件怎么处理？

- 浏览器有GUI渲染线程与JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。
- 渲染过程中，如果遇到`<script>`就停止渲染，执行 JS 代码。
- 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。也可以给 script 标签添加 defer 或者 async 属性。

补充说明：

- async和defer的作用是什么？有什么区别?
  - async 属性表示异步执行，如果已经加载好，就会开始执行——无论此刻是 HTML 解析这种方式依然会阻塞 load 事件。
  - defer 属性表示延迟执行，即这段 JS加载时 HTML 并未停止解析，这两个过程是并行的。document 解析完毕且 defer-script 也加载完成之后，会执行所有由 defer-script 加载的 JS 代码。



### 回流重绘：

- 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式。
- 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）

回流**必定**会发生重绘，重绘**不一定**会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

- 常见引起回流属性和方法

  任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流，

  - 添加或者删除可见的DOM元素；
  - 元素尺寸改变——边距、填充、边框、宽度和高度
  - 内容变化，比如用户在input框中输入文字
  - 浏览器窗口尺寸改变——resize事件发生时
  - 计算 offsetWidth 和 offsetHeight 属性
  - 设置 style 属性的值

- 常见引起重绘属性和方法

  - color、border-style、visibility等

- 如何减少回流、重绘

  - 使用 transform 替代 top
  - 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
  - 不要把节点的属性值放在一个循环里当成循环里的变量。
  - 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
  - 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
  - CSS 选择符从右往左匹配查找，避免节点层级过多
  - 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。



### 渲染优化：

- JS优化：`<script>`标签加上 defer属性 和 async属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。

    - defer属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。
    - async属性： HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。

- CSS优化： `<link>` 标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能



> ## 输入url到页面渲染的过程中会发生什么

> ### 一、DNS 解析：将域名解析成 IP 地址



> ### 二、TCP 连接：TCP 三次握手

- 客户端发送一个携带SYN标志位的包，请求建立连接；

- 服务端响应一个携带SYN和ACK标志位的包，同意建立连接；

- 客户端再发送一个携带ACK标志位的包，表示连接成功，开始进行数据传输。

  为什么是三次连接？  
  是因为二次握手不牢靠，客户端发了一个请求建立的包，但是由于网络原因迟迟没有抵达服务器，客户端只能再发一次请求，这次成功抵达并完成了数据传输，但是过了一段时间，第一次延迟的请求也到了服务器，服务器并不知道这是无效请求，依旧撑场响应，如果是二次握手，那么这个时候就会建立一条无效连接。而如果是三次握手，那么客户端就能够丢弃这条连接，避免了无效的网络开销。



> ### 三、发送 HTTP 请求

请求报文由请求行（request line）、请求头（header）、请求体三个部分组成。

- 请求行包含请求方法、URL、协议版本

  - 请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。
  - URL 即请求地址，由 <协议>：//<主机>：<端口>/<路径>?<参数> 组成
  - 协议版本即 http 版本号

- 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔

  - 比如：**Host，表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。**

- 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。


> ### 四、服务器处理请求并返回 HTTP 报文

 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。

MVC 后台处理阶段：首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。

响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。

- 响应行包含：协议版本，状态码，状态码描述
  - 1xx：指示信息--表示请求已接收，继续处理。
  - 2xx：成功--表示请求已被成功接收、理解、接受。
  - 3xx：重定向--要完成请求必须进行更进一步的操作。
  - 4xx：客户端错误--请求有语法错误或请求无法实现。
  - 5xx：服务器端错误--服务器未能实现合法的请求。
- 响应头部包含响应报文的附加信息，由 名/值 对组成
- 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据



> ### 五、浏览器解析渲染页面

- 根据 HTML 解析出 DOM 树
- 根据 CSS 解析生成 CSS 规则树
- 结合 DOM 树和 CSS 规则树，生成渲染树
- 根据渲染树计算每一个节点的信息
- 根据计算好的信息绘制页面



> ### 六、断开连接：TCP 四次挥手

- 客户端发送一个携带FIN标识位的包，请求断开连接。
- 服务器响应一个携带ACK标志位的包，同意客户端断开连接。
- 服务器再发送一个携带FIN标志位的包，请求断开连接。
- 客户端响应一个携带ACK标识位的包，同意服务器断开连接。





> ## 状态码：

##### 1xx：指示信息--表示请求已接收，继续处理

**2XX 成功--表示请求已被成功接收、理解、接受**

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
- 206 Partial Content，进行范围请求

**3XX 重定向--要完成请求必须进行更进一步的操作**

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

**4XX 客户端错误--请求有语法错误或请求无法实现**

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

**5XX 服务器错误——服务器未能实现合法的请求**

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求