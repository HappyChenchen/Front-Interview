## TCP:

- 三次握手
  - 客户端发送 syn(同步序列编号) 请求，进入 syn_send 状态，等待确认
  - 服务端接收并确认 syn 包后发送 syn+ack 包，进入 syn_recv 状态
  - 客户端接收 syn+ack 包后，发送 ack 包，双方进入 established 状态
- 四次挥手
  - 客户端 -- FIN --> 服务端， FIN—WAIT
  - 服务端 -- ACK --> 客户端， CLOSE-WAIT
  - 服务端 -- ACK,FIN --> 客户端， LAST-ACK
  - 客户端 -- ACK --> 服务端，CLOSED
- 滑动窗口: 流量控制
- 拥塞处理
  - 慢开始
  - 拥塞避免
  - 快速重传
  - 快速恢复



## TCP与UDP

- udp和tcp
  - udp 用户报文协议
    - 一对多，多对一，一对一都可以
    - 不能够保证可靠传输
    - 首部比较短，有8字节
    - DNS属于udp
    - 不需要新建连接就可以传输，结束连接也不需要挥手
  - tcp 传输控制协议
    - 与UDP的对比
      - 一对一的，比如一个服务器连接一个客户端进行数据传输
      - 首部较长，有20字节
      - 能够在传输过程中保证可靠传输，无差错、有次序的传输
      - 需要新建连接之后才能传输数据，在数据传输结束之后需要断开连接
      - 在传输过程中会根据网络情况进行拥塞控制



## ISO的七层结构

- 物理层：透明比特流的传输
- 数据链路层：将透明比特流与字节帧进行转换，将透明比特流转换为可以传输的数据字节
- 网络层：进行子网之间的传输，通过路由控制，将数据从一个网络传输到另一个网络
- 传输层：实现数据的可靠传输
- 表达层：实现数据的解压、加密、压缩
- 会话层：会话的维护，新建关闭等
- 应用层：面向应用的一层



## HTTP、HTTPS

### http

- 特点：简单快速、灵活、无连接、无状态（为了更快处理事务）
- 报文
  - 请求报文：请求行（说明请求类型、请求资源和Http版本）、请求头（键值对，包含客户端环境和请求正文的信息）、空行（表示请求头结束）和请求体（多个参数）
  - 响应报文：状态行、响应头、空行和响应体
- 请求方法：
  - GET 请求指定的页面信息，并返回实体主体。
  - HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
  - POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。
  - PUT 从客户端向服务器传送的数据取代指定的文档的内容。
  - DELETE 请求服务器删除指定的页面。
- get与post
  - get的请求较长，一般将请求参数放在链接中，请求可以被缓存，一般不太适用于一些敏感数据的请求，多用于访问获取数据，GET请求在URL中传送的参数是有长度限制，GET请求参数会被完整保留在浏览器历史记录里。
  - post的请求一般讲请求参数放置在请求体里，请求不能够被缓存，适用于处理敏感数据，多用于发送待处理的数据，post的请求参数没有长度限制，post的请求参数不会保留在历史记录。
- 持久连接
  - HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的 开销。
  - 特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态。
  - 好处：减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外， 减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。
- 管线化：
  - 能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。通俗地讲，请求打包一次传输过去，响应打包一次传递回来。管线化的前提是在持久连接下。

### https

- 定义：

HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。主要作用是数据加密和身份认证。

- 为何出现：

http协议通信使用明文，内容可能被窃听，无法保证报文的完整性，容易篡改，不验证双方身份，容易伪装

- https的优势有：
  - 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥
  - 数据完整性：内容传输经过完整性校验
  - 身份认证：第三方无法伪造服务端（客户端）身份

- 加强隐私性——加密：

利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数（MD5）验证信息的完整性。

使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，**在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式**。

具体做法是：**发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信**。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。

- 校验完整性——数字签名：

数字签名的功效有：确定发送方身份、确定消息的完整性

数字签名的生成是现将一段文件用hash函数生成摘要，然后用发送者的私钥生成数字签名，与原文一起传递给接收者。

接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。

和消息本身一样，公钥不能在不安全的网络中直接发送给接收方。因此引入证书颁发机构（CA）。



### http与https

- 比较
  - HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;
  - HTTPS需要用到SSL证书，而HTTP不用;
  - HTTPS标准端口443，HTTP标准端口80;
  - HTTPS基于传输层，HTTP基于应用层;
  - HTTPS在浏览器显示绿色安全锁，HTTP没有显示;
- http的三次握手
  - SYN --- SYN+ACK --- ACK
- https的三次握手
  - 握手
    - 客户端向服务器发送client_random和加密方式
    - 服务器收到请求之后，发送CA证书以及server_ramdom
    - 客户端收到之后，利用公钥对CA证书验证，同时将证书中的加密密码发送给服务端
    - 服务端收到之后利用私钥对加密密码解密
    - 两端协商一个密码，进行交流验证
  - CA证书验证
    - 服务端发来CA证书和一个签名
    - 客户端收到之后用公钥解码签名
    - 如果解码成功，就验证了签名的正确性，解码后得到待签名内容，以及一个digest
    - 之后对待签名内容进行hash，得到一个digest，对比就可以验证CA证书的有效性



### http/2   http/3

- http/1.0：
  - 无法复用链接，完成即断开，**重新慢启动和 TCP 3次握手**
  - 队头阻塞、协议开销大和安全因素等多个缺陷
- http/1.0：
  - **长连接**(默认 keep-alive)，复用
  - host 字段指定对应的虚拟站点
  - 新增功能:
    - 断点续传
    - 身份认证
    - 状态管理
    - cache 缓存
      - Cache-Control
      - Expires
      - Last-Modified
      - Etag
- http/2：
  - 二进制格式化传输数据，二进制分帧层: 应用层和传输层之间
  - 多路复用：解决了浏览器限制同一个域名下的请求数量的问题，也更接近全速传输；
  - 首部压缩：在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，首部表在连接存续期内始终存在，由客户端和服务器渐进更新
  - 服务器推送：服务端能通过push的方式将客户端需要的内容预先推送过去，
- http/3：
  - 多路复用下如果丢包，http2不如http1。
  - Google新搞了一个基于 **UDP** 协议的 QUIC 协议，并且使用在了 HTTP/3 上，名为 HTTP-over-QUIC。特性有：
    - 0-RTT：类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。
    - 多路复用：TCP 协议本身没有多路复用功能，QUIC原生实现了。
    - 加密认证的报文
    - 向前纠错机制



## 跨域：

- 跨域产生的原因是由于浏览器出于自身的安全考虑，他限制ajax请求的发送，DOM节点的获取，cookie的获取等必须要符合同源策略，所谓同源指的就是端口、域名、协议都一样，才会被认为同源。

- 注意：

  - 有三个标签是允许跨域加载资源：img、link、script
  - 如果是协议和端口造成的跨域问题，“前台”是无能为力的。
  - 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。

- 跨域的解决方法大概有cors,jsonp,代理这几种

  - jsonp：

    - 原理就是依赖script标签之间的传递没有同源策略的限制；前端动态创建一个script标签，src中定义一个回调函数，在后端获取到回调函数后，将数据包裹在回调函数中传回。
  
  - jsonp优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。
  
    ```
      function jsonp(url, jsonpCallback, success) {
      const script = document.createElement('script')
        script.src = url
      script.async = true
        script.type = 'text/javascript'
      window[jsonpCallback] = function(data) {
          success && success(data)
        }
        document.body.appendChild(script)
      }
      ```
  
  - cors：原理就是在后端设置Access-Control-Allow-Origin来使得浏览器支持跨域的数据响应。
  
  - 代理：webpack中设置proxytable，设置代理，利用的是服务器之间的传递也没有同源策略的限制。
  
  - postMessage：otherWindow.postMessage(message, targetOrigin, [transfer]);
  
  - websocktet：Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

    - ```
    var ws = new WebSocket(url)
      ws.onopen = function(){
      ws.send(message)
      }
    ws.onclose = function(event){
        event.code
      event.reason
      }
    ws.onmessage = function(event){
        event.data
    }
      ```
  
  - Node中间件代理(两次跨域）
  
  - nginx反向代理：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。
  
  - window.name + iframe
  
  - location.hash + iframe：a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
  
  - document.domain + iframe：只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。
  
  - 总结：
  
    - CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
    - JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
    - 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。
    - 日常工作中，用得比较多的跨域方案是cors和nginx反向代理



## web实时推送技术

### 一、双向通信

HTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。如果服务器有连续的状态变化，客户端要获知就非常麻烦。**在WebSocket协议之前，有三种实现双向通信的方式：轮询（polling）、长轮询（long-polling）和iframe流（streaming）**。

- 轮询：客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。
  - 优点：实现简单，无需做过多的更改
  - 缺点：轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担
- 长轮询：客户端发送HTTP给服务器之后，看有没有新消息，如果没有新消息，就一直等待。当有新消息的时候，才会返回给客户端。
  - 优点：比 Polling 做了优化，有较好的时效性
  - 缺点：保持连接会消耗资源; 服务器没有返回有效数据，程序超时。
- iframe流：iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。
  - 优点：消息能够实时到达；浏览器兼容好
  - 缺点：服务器维护一个长连接会增加开销；IE、chrome、Firefox会显示加载没有完成，图标会不停旋转。



### 二、WebSocket

WebSocket是一种全新的协议。它将TCP的Socket（套接字）应用在了webpage上，从而使通信双方建立起一个保持在活动状态连接通道。由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。

**WebSocket的特点：**

- 支持双向通信，实时性更强
- 可以发送文本，也可以发送二进制数据
- 减少通信量：只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。
- 在海量并发和客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。

```
var ws = new WebSocket(url)
ws.onopen = function(){
  ws.send(message)
}
ws.onclose = function(event){
  event.code
  event.reason
}
ws.onmessage = function(event){
  event.data
}
```





## AJAX

**Ajax的目的是提高用户体验，较少网络数据的传输量**。

最核心的依赖是浏览器提供的XMLHttpRequest对象

