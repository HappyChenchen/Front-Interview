##  浏览器存储：

### cookie:

由于http是无状态的，使用cookie使浏览器和服务器之间传递数据。

典型的应用场景有：记住密码，下次自动登录；购物车功能；记录用户浏览数据，进行商品（广告）推荐。

缺点：每个http请求都带了cookie，使得首部内容增加，影响带宽；不适合存储私人敏感信息；大小限制4kb左右。


### localStorage：

- 保存的数据长期存在，同源的本地数据可以共享。

- 大小为5M左右

- 仅在客户端使用，不和服务端进行通信

- 接口封装较好

  

### sessionStorage:

- 会话级别的浏览器存储
- 大小为5M左右
- 仅在客户端使用，不和服务端进行通信
- 接口封装较好

sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，**即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享**；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。



### IndexDB

IndexDB  用于客户端存储大量结构化数据**(包括文件和blobs)**。没有存储上限（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。



### 四者区别：

- 生命周期：cookie由服务器生成，设置过期时间即可；local除非被清理，否则一直存在；session页面关闭就清理；IndexDB除非被清理，否则一直存在
- 存储大小：4k 5M 5M 无限
- 与服务端通信：cookie每次都携带在header中，有性能影响；别的都不参与



##  浏览器缓存：

<https://github.com/ljianshu/Blog/issues/23>

缓存的作用是不言而喻的，能够极大的改善网页性能，提高用户体验。

### 缓存位置

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache



### 缓存过程

浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。

- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中



### 强缓存与协商缓存

Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，**Cache-Control的 max-age 优先级高于 Expires**

当缓存已经过期时，使用协商缓存

- 唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，
- 最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified) 
  - 如果一致，则直接返回 304 通知浏览器使用缓存
  - 如不一致，则服务端返回新的资源

Last-Modified 缺点：

- 周期性修改，但内容未变时，会导致缓存失效
- 最小粒度只到 s， s 以内的改动无法检测到

Etag 的优先级高于 Last-Modified



### 默认缓存策略：

**如果什么缓存策略都没设置，那么浏览器会怎么处理？**
 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 `Date` 减去 `Last-Modified` 值的 10% 作为缓存时间。

 

### 实际场景应用缓存策略

- 频繁变动的资源  Cache-Control: no-cache
- 不常变化的资源  Cache-Control: max-age=31536000



### 用户行为影响

- 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
- 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
- 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control: no-cache`(为了兼容，还带了 `Pragma: no-cache`),服务器直接返回 200 和最新内容。





##  浏览器渲染：

目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。这里面大家最耳熟能详的可能就是 Webkit 内核了，Webkit 内核是当下浏览器世界真正的霸主。

### 浏览器渲染过程：

浏览器页面加载过程：

- 浏览器根据 DNS 服务器得到域名的 IP 地址
- 向这个 IP 的机器发送 HTTP 请求
- 服务器收到、处理并返回 HTTP 请求
- 浏览器得到返回内容

浏览器渲染过程：

- 构建DOM -> 构建CSSOM -> 构建渲染树 -> 布局 -> 绘制。

浏览器如果渲染过程中遇到JS文件怎么处理？

- 浏览器有GUI渲染线程与JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。
- 渲染过程中，如果遇到`<script>`就停止渲染，执行 JS 代码。
- 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。也可以给 script 标签添加 defer 或者 async 属性。

补充说明：

- async和defer的作用是什么？有什么区别?
  - async 属性表示异步执行，如果已经加载好，就会开始执行——无论此刻是 HTML 解析这种方式依然会阻塞 load 事件。
  - defer 属性表示延迟执行，即这段 JS加载时 HTML 并未停止解析，这两个过程是并行的。document 解析完毕且 defer-script 也加载完成之后，会执行所有由 defer-script 加载的 JS 代码。



### 回流重绘：

- 重绘：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 **损耗较少**
- 回流： 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:

回流**必定**会发生重绘，重绘**不一定**会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

- 常见引起回流属性和方法

  - 页面初次渲染
  - 浏览器窗口大小改变
  - 元素尺寸、位置、内容发生改变
  - 元素字体大小变化
  - 添加或者删除可见的 dom 元素
  - 激活 CSS 伪类（例如：:hover）
  - 查询某些属性或调用某些方法 
    - clientWidth、clientHeight、clientTop、clientLeft
    - offsetWidth、offsetHeight、offsetTop、offsetLeft
    - scrollWidth、scrollHeight、scrollTop、scrollLeft
    - getComputedStyle()
    - getBoundingClientRect()
    - scrollTo()

- 常见引起重绘属性和方法

  - color、border-style、visibility等

- 如何减少回流、重绘

  - css
  
    - 避免使用`table`布局
    - 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上
  
  - javascript
  
    - 避免频繁操作样式，可汇总后统一 **一次修改**
    - 尽量使用`class`进行样式修改
    - 减少`dom`的增删次数，可使用 **字符串** 或者 `documentFragment` 一次性插入
    - 极限优化时，修改样式可将其`display: none`后修改
    - 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 **变量存住**
  
  
    

### 渲染优化：

- JS优化：`<script>`标签加上 defer属性 和 async属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。

    - defer属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。
    - async属性： HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。

- CSS优化： `<link>` 标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能



## 输入url到页面渲染的过程中会发生什么

### 一、DNS 解析：将域名解析成 IP 地址



### 二、TCP 连接：TCP 三次握手

- 客户端发送一个携带SYN标志位的包，请求建立连接；

- 服务端响应一个携带SYN和ACK标志位的包，同意建立连接；

- 客户端再发送一个携带ACK标志位的包，表示连接成功，开始进行数据传输。

  为什么是三次连接？  
  是因为二次握手不牢靠，客户端发了一个请求建立的包，但是由于网络原因迟迟没有抵达服务器，客户端只能再发一次请求，这次成功抵达并完成了数据传输，但是过了一段时间，第一次延迟的请求也到了服务器，服务器并不知道这是无效请求，依旧撑场响应，如果是二次握手，那么这个时候就会建立一条无效连接。而如果是三次握手，那么客户端就能够丢弃这条连接，避免了无效的网络开销。



### 三、发送 HTTP 请求

请求报文由请求行（request line）、请求头（header）、请求体三个部分组成。

- 请求行包含请求方法、URL、协议版本

  - 请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。
  - URL 即请求地址，由 <协议>：//<主机>：<端口>/<路径>?<参数> 组成
  - 协议版本即 http 版本号

- 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔

  - 比如：**Host，表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。**

- 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。


### 四、服务器处理请求并返回 HTTP 报文

 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。

MVC 后台处理阶段：首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。

响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。

- 响应行包含：协议版本，状态码，状态码描述
  - 1xx：指示信息--表示请求已接收，继续处理。
  - 2xx：成功--表示请求已被成功接收、理解、接受。
  - 3xx：重定向--要完成请求必须进行更进一步的操作。
  - 4xx：客户端错误--请求有语法错误或请求无法实现。
  - 5xx：服务器端错误--服务器未能实现合法的请求。
- 响应头部包含响应报文的附加信息，由 名/值 对组成
- 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据



### 五、浏览器解析渲染页面

- 根据 HTML 解析出 DOM 树
- 根据 CSS 解析生成 CSS 规则树
- 结合 DOM 树和 CSS 规则树，生成渲染树
- 根据渲染树计算每一个节点的信息
- 根据计算好的信息绘制页面



### 六、断开连接：TCP 四次挥手

- 客户端发送一个携带FIN标识位的包，请求断开连接。
- 服务器响应一个携带ACK标志位的包，同意客户端断开连接。
- 服务器再发送一个携带FIN标志位的包，请求断开连接。
- 客户端响应一个携带ACK标识位的包，同意服务器断开连接。





## 状态码：

**1xx：指示信息--表示请求已接收，继续处理**

**2XX 成功--表示请求已被成功接收、理解、接受**

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
- 206 Partial Content，进行范围请求

**3XX 重定向--要完成请求必须进行更进一步的操作**

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

**4XX 客户端错误--请求有语法错误或请求无法实现**

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

**5XX 服务器错误——服务器未能实现合法的请求**

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求



## V8垃圾回收机制

垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 **新生代空间** 和 **老生代空间**。

- 新生代空间: 用于存活较短的对象 
  - 又分成两个空间: from 空间 与 to 空间
  - Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法 
    - 存活的对象从 from space 转移到 to space
    - 清空 from space
    - from space 与 to space 互换
    - 完成一次新生代GC
- 老生代空间: 用于存活时间较长的对象 
  - 从 新生代空间 转移到 老生代空间 的条件 
    - 经历过一次以上 Scavenge GC 的对象
    - 当 to space 体积超过25%
  - **标记清除算法**: 标记存活的对象，未被标记的则被释放 
    - 增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能
    - 并发标记(最新技术): 不阻塞 js 执行
  - **压缩算法**: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 **内存的碎片化**



## 内存泄露

- 意外的**全局变量**: 无法被回收
- **定时器**: 未被正确关闭，导致所引用的外部变量无法被释放
- **事件监听**: 没有正确销毁 (低版本浏览器可能出现)
- **闭包**: 会导致父级中的变量无法被释放
- **dom 引用**: dom 元素被删除时，内存中的引用未被正确清空

可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。

