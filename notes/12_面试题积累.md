
- #### TCP与UDP区别
  - TCP面向连接；UDP是无连接的，即发送数据之前不需要建立连接

  - TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；

    UDP尽最大努力交付，不保证可靠交付；

    Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

  - UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

  - 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。

  - TCP对系统资源要求较多，UDP对系统资源要求较少。

  

- #### HTTP组成部分，你能想起来哪些字段




- #### 死锁及其原因解决办法，其他锁

  <https://blog.csdn.net/guaiguaihenguai/article/details/80303835>

  <https://www.cnblogs.com/sunnyCx/p/8108687.html>



- #### 事件流，阻止冒泡的方法，IE




- #### css优先级，important和内联谁优先级更高？

  

- #### 回流和重绘，什么时候会重绘但是不回流
  - 重绘是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘
  - 回流是页面布局或者几何属性需要改变。

  回流**必定**会发生重绘，重绘**不一定**会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。



- #### 闭包,手写闭包




- #### 算法题，去掉字符串中的 'b' 和 'ac' 结构。


```
//字符串中删除ac和b
function delacb(str) {
  let strAr = str.split("");
  for (let i = 0; i < strAr.length; i++) {
    if (strAr[i] == "b") {
      strAr.splice(i, 1);
      if (i >= 1) {
        i--;
      }
    } else if (strAr[i] == "a" && strAr[i + 1] == "c") {
      strAr.splice(i, 2);
      if (i >= 1) {
        i--;
      }
    }
  }
  return strAr.join("");
}
```



- #### Promise.all的实现原理


简单来说就是把所有要执行的函数都放进一个数组里面，然后数组以次以**同步**的形式一个一个执行，执行结束后能够接着执行then里面的东西。

```
//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)
Promise.all = function(promises) {
  let arr = [];
  let i = 0;
  function processData(index, data) {
    arr[index] = data;
    i++;
    if (i == promises.length) {
      resolve(arr);
    }
  }
  return new Promise((resolve, reject) => {
    for (let i = 0; i < promises.length; i++) {
      promises[i].then(data => {
        processData(i, data);
      }, reject);
    }
  });
};
```



- #### Array.prototype.reduce原理


```
//reduce
if (typeof Array.prototype.reduce != "function") {
  Array.prototype.reduce = function(callback, initialValue) {
    var previous = initialValue,
      k = 0,
      length = this.length;
    if (typeof initialValue === "undefined") {
      previous = this[0];
      k = 1;
    }

    if (typeof callback === "function") {
      for (k; k < length; k++) {
        this.hasOwnProperty(k) &&
          (previous = callback(previous, this[k], k, this));
      }
    }
    return previous;
  };
}
```



- #### Vue双向绑定原理，手写数据劫持

  <https://www.cnblogs.com/tugenhua0707/p/10306793.html>

  ##### vue2

  - vue的双向数据绑定依赖三个主要的功能模块：

    - 观察者：利用object.defineProperty的get方法来获取当前的数据值，当属性值变化的时候会触发set方法来通知订阅者
    - 订阅者：维护一个订阅者列表，在观察者和指令解析器之间传递消息，收到更新通知之后，触发指令解析器
    - 指令解析器：解析指令模板，对不同的指令模板做出对应的处理，比如v-model模板中可以添加对input事件的监听，v-on模板中添加对应事件的监听，{{}}数据模板则是将对应的数据属性添加到订阅者列表中

  - 有了这三个模块之后，整个数据双向绑定的过程可以理解为这样的几个步骤：

    - 首先，在vue实例创建的时候，对跟组件的所有元素进行遍历解析，解析的过程中是生成虚拟文档节点进行解析的，解析的过程中对不同的指令模板做出对应的处理，同时将绑定的data中的属性值添加到订阅者列表中
    - 当数据变化的时候，会触发set方法，进而触发指令解析器，对节点的value值进行更新，从而更新视图
    - 当视图变化的时候，对应的事件会监听到，进而可以更新对应的数据值

    ```
    <!DOCTYPE html>
     <html>
        <head>
          <meta charset="utf-8">
          <title>标题</title>
        </head>
        <body>
          <input type="text" id="demo" />
          <div id="xxx">{{name}}</div>
    
          <script type="text/javascript">
            const obj = {};
            Object.defineProperty(obj, 'name', {
              set: function(value) {
                document.getElementById('xxx').innerHTML = value;
                document.getElementById('demo').value = value;
              }
            });
            document.querySelector('#demo').oninput = function(e) {
              obj.name = e.target.value;
            }
            obj.name = '';
          </script>
        </body>
    </html>
    ```

    

  ##### vue3

  当我们使用数组的方法或改变数组的下标是不能重新触发 Object.defineProperty中的set()方法的，因此就做不到实时响应了。所以使用 Object.defineProperty 存在如下缺点：

1. 监听数组的方法不能触发Object.defineProperty方法中的set操作(如果要监听到的话，需要重新编写数组的方法)。
2. 必须遍历每个对象的每个属性，如果对象嵌套很深的话，需要使用递归调用。

因此vue3.xx中之后就改用Proxy来更好的解决如上面的问题。

**Proxy基本语法**

```
const obj = new Proxy(target, handler);
//参数说明如下：
target: 被代理对象。
handler:是一个对象，声明了代理target的一些操作。
obj: 是被代理完成之后返回的对象。
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>proxy</title>
</head>
<body>
    <h1>使用Proxy 和 Reflect 实现双向数据绑定</h1>
    <input type="text" id="input">
    <h2>您输入的内容是： <i id="txt"></i></h2>
    <script>
        //获取dom元素
        let oInput = document.getElementById("input");
        let oTxt = document.getElementById("txt");

        //初始化代理对象
        let obj = {};

        //给obj增加代理对象
        let newProxy = new Proxy(obj,{
            get: (target,key,recevier)=>{
                //console.log("get:"+ key)
                return Reflect.get(target,key,recevier);
            },
            set: (target,key,value,recevier)=>{
                //监听newProxy是否有新的变化
                if(key == "text"){
                    oTxt.innerHTML = value;
                }
                
                //将变化反射回原有对象
                return Reflect.set(target,key,value,recevier);
            }
        })

        //监听input输入事件
        oInput.addEventListener("keyup",(e)=>{
            //修改代理对象的值
            newProxy.text = e.target.value;
        })
    </script>
</body>
</html>
```


