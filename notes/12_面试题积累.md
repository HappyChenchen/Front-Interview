
- #### TCP与UDP区别
  - TCP面向连接；UDP是无连接的，即发送数据之前不需要建立连接

  - TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；

    UDP尽最大努力交付，不保证可靠交付；

    Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

  - UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

  - 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。

  - TCP对系统资源要求较多，UDP对系统资源要求较少。

  

- #### HTTP组成部分，你能想起来哪些字段




- #### 死锁及其原因解决办法，其他锁

  <https://blog.csdn.net/guaiguaihenguai/article/details/80303835>

  <https://www.cnblogs.com/sunnyCx/p/8108687.html>



- #### 事件流，阻止冒泡的方法，IE




- #### css优先级，important和内联谁优先级更高？

  

- #### 回流和重绘，什么时候会重绘但是不回流
  - 重绘是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘
  - 回流是页面布局或者几何属性需要改变。

  回流**必定**会发生重绘，重绘**不一定**会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。



- #### 闭包,手写闭包




- #### 算法题，去掉字符串中的 'b' 和 'ac' 结构。


```
//字符串中删除ac和b
function delacb(str) {
  let strAr = str.split("");
  for (let i = 0; i < strAr.length; i++) {
    if (strAr[i] == "b") {
      strAr.splice(i, 1);
      if (i >= 1) {
        i--;
      }
    } else if (strAr[i] == "a" && strAr[i + 1] == "c") {
      strAr.splice(i, 2);
      if (i >= 1) {
        i--;
      }
    }
  }
  return strAr.join("");
}
```



- #### Promise.all的实现原理


简单来说就是把所有要执行的函数都放进一个数组里面，然后数组以次以**同步**的形式一个一个执行，执行结束后能够接着执行then里面的东西。

```
//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)
Promise.all = function(promises) {
  let arr = [];
  let i = 0;
  function processData(index, data) {
    arr[index] = data;
    i++;
    if (i == promises.length) {
      resolve(arr);
    }
  }
  return new Promise((resolve, reject) => {
    for (let i = 0; i < promises.length; i++) {
      promises[i].then(data => {
        processData(i, data);
      }, reject);
    }
  });
};
```



- #### Array.prototype.reduce原理


```
//reduce
if (typeof Array.prototype.reduce != "function") {
  Array.prototype.reduce = function(callback, initialValue) {
    var previous = initialValue,
      k = 0,
      length = this.length;
    if (typeof initialValue === "undefined") {
      previous = this[0];
      k = 1;
    }

    if (typeof callback === "function") {
      for (k; k < length; k++) {
        this.hasOwnProperty(k) &&
          (previous = callback(previous, this[k], k, this));
      }
    }
    return previous;
  };
}
```



- #### Vue双向绑定原理，手写数据劫持

  <https://www.cnblogs.com/tugenhua0707/p/10306793.html>

  ##### vue2

  - vue的双向数据绑定依赖三个主要的功能模块：

    - 观察者：利用object.defineProperty的get方法来获取当前的数据值，当属性值变化的时候会触发set方法来通知订阅者
    - 订阅者：维护一个订阅者列表，在观察者和指令解析器之间传递消息，收到更新通知之后，触发指令解析器
    - 指令解析器：解析指令模板，对不同的指令模板做出对应的处理，比如v-model模板中可以添加对input事件的监听，v-on模板中添加对应事件的监听，{{}}数据模板则是将对应的数据属性添加到订阅者列表中

  - 有了这三个模块之后，整个数据双向绑定的过程可以理解为这样的几个步骤：

    - 首先，在vue实例创建的时候，对跟组件的所有元素进行遍历解析，解析的过程中是生成虚拟文档节点进行解析的，解析的过程中对不同的指令模板做出对应的处理，同时将绑定的data中的属性值添加到订阅者列表中
    - 当数据变化的时候，会触发set方法，进而触发指令解析器，对节点的value值进行更新，从而更新视图
    - 当视图变化的时候，对应的事件会监听到，进而可以更新对应的数据值

    ```
    <!DOCTYPE html>
     <html>
        <head>
          <meta charset="utf-8">
          <title>标题</title>
        </head>
        <body>
          <input type="text" id="demo" />
          <div id="xxx">{{name}}</div>
    
          <script type="text/javascript">
            const obj = {};
            Object.defineProperty(obj, 'name', {
              set: function(value) {
                document.getElementById('xxx').innerHTML = value;
                document.getElementById('demo').value = value;
              }
            });
            document.querySelector('#demo').oninput = function(e) {
              obj.name = e.target.value;
            }
            obj.name = '';
          </script>
        </body>
    </html>
    ```

  ##### vue3
  
  当我们使用数组的方法或改变数组的下标是不能重新触发 Object.defineProperty中的set()方法的，因此就做不到实时响应了。所以使用 Object.defineProperty 存在如下缺点：

1. 监听数组的方法不能触发Object.defineProperty方法中的set操作(如果要监听到的话，需要重新编写数组的方法)。
2. 必须遍历每个对象的每个属性，如果对象嵌套很深的话，需要使用递归调用。

因此vue3.xx中之后就改用Proxy来更好的解决如上面的问题。

**Proxy基本语法**

```
const obj = new Proxy(target, handler);
//参数说明如下：
target: 被代理对象。
handler:是一个对象，声明了代理target的一些操作。
obj: 是被代理完成之后返回的对象。
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>proxy</title>
</head>
<body>
    <h1>使用Proxy 和 Reflect 实现双向数据绑定</h1>
    <input type="text" id="input">
    <h2>您输入的内容是： <i id="txt"></i></h2>
    <script>
        //获取dom元素
        let oInput = document.getElementById("input");
        let oTxt = document.getElementById("txt");

        //初始化代理对象
        let obj = {};

        //给obj增加代理对象
        let newProxy = new Proxy(obj,{
            get: (target,key,recevier)=>{
                //console.log("get:"+ key)
                return Reflect.get(target,key,recevier);
            },
            set: (target,key,value,recevier)=>{
                //监听newProxy是否有新的变化
                if(key == "text"){
                    oTxt.innerHTML = value;
                }
                
                //将变化反射回原有对象
                return Reflect.set(target,key,value,recevier);
            }
        })

        //监听input输入事件
        oInput.addEventListener("keyup",(e)=>{
            //修改代理对象的值
            newProxy.text = e.target.value;
        })
    </script>
</body>
</html>
```



- #### 继承的五种方法：

  https://blog.csdn.net/qq_39936163/article/details/95199011

  1. 构造函数继承

     ```
     function Parent1 () {
       this.name= '111';
     }
     function Child1 () {
       Parent1.call(this);
       this.type='222';
     } 
     ```

     通过这种方式，只能继承定义在父类构造函数内的属性与方法，定义在prototype原型对象内的属性与方法则无法继承，因此对其改进。

  2. 原型对象进行继承

     ```
     function Parent2 () {
       this.name= '111';
     }
     function Child2 () {
       this.type='222';
     } 
     Child2.prototype = new Parent2();
     ```

     通过这种方式，则既能继承构造函数内的属性与方法，也能继承原型链上的属性与方法。但是，由于令其原型对象指向父类的一个实例对象，使得所有子类的实例对象所访问到的属性指向同一个对象，所以会出现改变一个子类实例对象的父类中的属性，另一个子类对象的属性也跟着改变。因此我们有下一个方法来改进：

  3. 组合方法：

     ```
     function Parent3 () {
       this.name = '111';
     }
     function Child3 () {
       Parent3.call(this);
       this.type ='222';
     } 
     Child3.prototype = new Parent3();
     ```

     父类的构造函数执行了两次，为了减少父类的构造函数的不必要的多次执行，如下修改代码。

  4. 组合方法优化：

     ```
     function Parent4 () {
       this.name= '111';
     }
     function Child4 () {
       Parent4.call(this);
       this.type='222';
     } 
     Child4.prototype = Parent4.prototye;
     ```

     这样解决了前面提到的问题，但是这样简单粗暴的继承，使子类的原型对象指向了父类的原型对象，会导致当子类实例对象通过constructor属性获取其构造函数时，获得的是父类的构造函数（因为constructor属性在prototype属性中被继承），因此再进行优化

  5. 组合方法优化2

     ```
     function Parent5 () {
       this.name= '111';
     }
     function Child5 () {
       Parent5.call(this);
       this.type='222';
     } 
     Child5.prototype = Object.create(Parent5.prototype);
     Child5.prototype.constructor = Child5;
     ```

     由于Object.create()这个api的特性，父类的原型对象会继承在子类的原型对象的原型对象上，实现了子类原型对象与父类原型对象的隔离，这时再给子类的原型对象的constructor属性赋值。为什么直接在第四种方式的后面直接赋值呢？因为这是子类与父类的原型对象指向同一个对象，修改属性会同时修改子类与父类的原型对象。



- #### devDependencies与dependencies的区别

在使用npm install 安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，他们是：--save-dev或-save

使用 --save-dev 安装的 插件，被写入到 devDependencies 域里面去，而使用 --save 安装的插件，则是被写入到 dependencies 区块里面去。

那 package.json 文件里面的 devDependencies  和 dependencies 对象有什么区别呢？

- `devDependencies`：生产环境使用
- `dependencies`：线上环境使用

devDependencies  里面的插件只用于开发环境，不用于生产环境，而 dependencies  是需要发布到生产环境的。

比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies ；

而我们使用的一些构建工具比如glup、webpack这些只是在开发中使用的包，上线以后就和他们没关系了，所以将它写入devDependencies。



- #### packge.json   npm init
  - name 项目名称
  - version 项目的版本号
  - description 项目的描述信息
  - entry point 项目的入口文件
  - test command 项目启动时脚本命令
  - git repository 如果你有 Git 地址，可以将这个项目放到你的 Git 仓库里
  - keywords 关键词
  - author 作者叫啥
  - license 项目要发行的时候需要的证书，平时忽略它