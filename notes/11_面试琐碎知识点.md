## 死锁及其原因解决办法，其他锁

<https://blog.csdn.net/guaiguaihenguai/article/details/80303835>

<https://www.cnblogs.com/sunnyCx/p/8108687.html>

**概念：** 指一个资源被多次调用，而多次调用方都未能释放该资源就会造成一种互相等待的现象，若无外力作用，它们都将无法推进下去。

**原因： **系统资源有限、进程推进顺序不合理。

**四个必要条件：**

- **互斥： **一个资源每次只能被一个进程使用。
- **占有且等待： **一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- **不可抢占： **进程已获得的资源，在末使用完之前，不能强行剥夺，只能在进程使用完时由自己释放。
- **循环等待： **若干进程之间形成一种头尾相接的循环等待资源关系。

**解决办法：**

（1）预防

1. 破坏“占有且等待”条件：

   每个进程在运行前必须一次性的申请它所要求的全部资源，且仅当该进程所要的资源均可满足时才一次性的分配。

2. 破坏“不可抢占”条件：

   根据进程的不同优先级，通过操作系统抢占这一资源

3. 破坏“循环等待”条件：

   定义资源类型的线性顺序，把资源中所有的资源编号，进程在申请资源时，必须严格按照资源编号的递增次序进行，否则操作系统不予分配。

（2）避免

1. 如果一个进程的请求会导致死锁，则不启动该进程
2. 如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。

**其他锁：**

同步锁：进程或者线程A和B一块配合，A执行到一定程序时需要依赖B的某个结果，于是停下来，示意B运行；B执行，再将结果给A；A再继续操作。

互斥锁：互斥锁为资源引入一个状态：锁定/非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。