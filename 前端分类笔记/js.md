- - -

## JS的数据类型

- undefined、null，boolean,string,number
- 基本类型：undefined、null，boolean,string
- 引用类型：object,array,regexp,function,date
- 数据类型判断：
  - 基本类型判断：typeof ===== 结果：undefined，null，number，boolean，string，object
  - 引用类型判断



## JS操作DOM

- appendChild，insertBefore，removeChild,replaceChild
- querySelector，querySelectorAll，getElementById，getElementsByClassName，getElementsByTagName



## 深拷贝与浅拷贝

- 浅拷贝：拷贝地址
- 深拷贝：创建新的内存，递归属性复制



## 作用域

- 就是变量作用的范围，查找变量是顺着作用域链来的，在当前作用域搜索，如果没有则在上级搜寻，逐级上升直至查找到全局作用域
- 私有作用域：函数执行的过程中创造的作用域叫私有作用域，其中的变量包含形参、私有作用域中声明的变量
  - 函数执行的过程
    - 为形参赋值
    - 预解释私有作用域中的变量
    - 执行函数中的代码
- 全局作用域：在全局声明的作用域

## 闭包

- 能够引用外部作用域变量的函数叫做闭包。常见的形式是比如我们定义一个函数，在函数中返回了一个函数，将这个返回的函数赋值给全局作用域的一个变量，那么就形成了一个闭包。我们在编码中比较常见的setTimeout中的回调函数，DOM元素触发一个事件函数，这些其实都包含着闭包
- 闭包可能造成的问题就是内存泄漏，因为函数在执行结束之后他的私有作用域所占的内存就会被销毁，但是因为其内部的函数被引用了，所以函数作用域无法被销毁，导致内存泄漏。
- 闭包的主要作用包含几个点，第一是通过一个立即执行函数生成一个块级作用域，比如说ES5中for循环里面用setTimeout逐个输出1，2，3，4，5这样，就可以使用闭包来实现;第二是创建特权方法，类似于模块化包装，可以暴露一些包装函数的公共API



## 原型链

- 首先说一下原型链的含义：每个构造函数都拥有一个prototype属性，这个属性指向一个原型对象，而这个原型对象拥有一个constructor属性，这个属性指向原构造函数。当我们为构造函数创造一个实例的时候，实例就会拥有一个Prototype属性，该属性指向构造函数的原型对象，这样就构造了一个链式，就被称为原型链
- 原型链通常被用于实现属性和方法的继承。因为构造函数的原型中定义的方法是可以共享的。比如我们最常用的构造函数和原型组合的继承方式就是在超类构造函数中定义共享的属性，利用原型定义共享的方法，在子类中引用超类，同时将子类的原型赋予给超类的实例，这样就实现了子类对超类的继承
- 此外还可以根据原型上定义的方法是共享的这个特性，我们可以定义一些函数，或者数组共享的API，比如我们可以在JS中通过Function.prototype.bind定义一个显式绑定this指向的bind方法，来让所有函数共享