## TCP与UDP

- udp和tcp
  - udp 用户报文协议
    - 一对多，多对一，一对一都可以
    - 不能够保证可靠传输
    - 首部比较短，有8字节
    - DNS属于udp
    - 不需要新建连接就可以传输，结束连接也不需要挥手
  - tcp 传输控制协议
    - 与UDP的对比
      - 一对一的，比如一个服务器连接一个客户端进行数据传输
      - 首部较长，有20字节
      - 能够在传输过程中保证可靠传输，无差错、有次序的传输
      - 需要新建连接之后才能传输数据，在数据传输结束之后需要断开连接
      - 在传输过程中会根据网络情况进行拥塞控制



## ISO的七层结构

- 物理层：透明比特流的传输
- 数据链路层：将透明比特流与字节帧进行转换，将透明比特流转换为可以传输的数据字节
- 网络层：进行子网之间的传输，通过路由控制，将数据从一个网络传输到另一个网络
- 传输层：实现数据的可靠传输
- 表达层：实现数据的解压、加密、压缩
- 会话层：会话的维护，新建关闭等
- 应用层：面向应用的一层



## HTTP

- http与https
  - 比较
    - https相比于http，在下面添加了SSL层，两端通信的时候需要进行证书验证，适合传输敏感数据
  - http的三次握手
    - SYN --- ACK --- ACK
  - https的三次握手
    - 握手
      - 客户端向服务器发送client_random和加密方式
      - 服务器收到请求之后，发送CA证书以及server_ramdom
      - 客户端收到之后，利用公钥对CA证书验证，同时将证书中的加密密码发送给服务端
      - 服务端收到之后利用私钥对加密密码解密
      - 两端协商一个密码，进行交流验证
    - CA证书验证
      - 服务端发来CA证书和一个签名
      - 客户端收到之后用公钥解码签名
      - 如果解码成功，就验证了签名的正确性，解码后得到待签名内容，以及一个digest
      - 之后对待签名内容进行哈希，得到一个digest，对比就可以验证CA证书的有效性
- get与post
  - get的请求较长，一般将请求参数放在链接中，请求可以被缓存，一般不太适用于一些敏感数据的请求，多用于访问获取数据
  - post的请求一般讲请求参数放置在请求体里，请求不能够被缓存，适用于处理敏感数据，多用于发送待处理的数据



## 跨域：

- 跨域产生的原因是由于浏览器出于自身的安全考虑，他限制ajax请求的发送，DOM节点的获取，cookie的获取等必须要符合同源策略，所谓同源指的就是端口、域名、协议都一样，才会被认为同源。

- 注意：

  - 有三个标签是允许跨域加载资源：<img>、<link>、<script>
  - 如果是协议和端口造成的跨域问题，“前台”是无能为力的。
  - 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。

- 跨域的解决方法大概有cors,jsonp,代理这几种

  - jsonp：

    - 原理就是依赖script标签之间的传递没有同源策略的限制；前端动态创建一个script标签，src中定义一个回调函数，在后端获取到回调函数后，将数据包裹在回调函数中传回。
    - jsonp优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。

  - cors：原理就是在后端设置Access-Control-Allow-Origin来使得浏览器支持跨域的数据响应。

  - 代理：webpack中设置proxytable，设置代理，利用的是服务器之间的传递也没有同源策略的限制。

  - postMessage：otherWindow.postMessage(message, targetOrigin, [transfer]);

  - websocktet：Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

    - ```
      var ws = new WebSocket(url)
      ws.onopen = function(){
        ws.send(message)
      }
      ws.onclose = function(event){
        event.code
        event.reason
      }
      ws.onmessage = function(event){
        event.data
      }
      ```

  - Node中间件代理(两次跨域）

  - nginx反向代理：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

  - window.name + iframe

  - location.hash + iframe：a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

  - document.domain + iframe：只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。

  - 总结：

    - CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
    - JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
    - 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。
    - 日常工作中，用得比较多的跨域方案是cors和nginx反向代理