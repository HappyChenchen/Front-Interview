## 事件流，阻止冒泡的方法

- 事件流包括三个阶段：事件捕获。处于目标。事件冒泡。
- 为DOM绑定事件之后，当用户触发到某元素的事件之时，则会从document开始一级一级的向下查找到对应的元素，该阶段为捕获阶段；到达目标之后则为目标阶段；触发目标的处理程序之后，则从目标一级一级的向上直到document，这个阶段为冒泡阶段。
- 一般都是使用冒泡事件流来进行事件的处理；
  - 事件冒泡的作用主要是允许多个操作被集中处理，例如一个列表的每一个字段点击都会出现相应的处理反应，则可以直接为所有字段的上一级元素绑定处理程序；
  - 但是有些程序相反需要取消冒泡机制带来的弊端，此时可以使用阻止事件冒泡的方法，
- js事件机制包括：事件绑定、事件监听、事件委托。
  - 事件绑定：
    - DOM元素绑定
    - js绑定
  - 事件监听：
    - W3C： element.addEventListener(event, function, useCapture);
    - element.attachEvent (event，function); 冒泡阶段执行
  - 事件委托：
    - 原理：利用冒泡，在所有需要绑定相同事件的子元素的父元素上绑定对应事件。
    - 优点：提高性能，减少事件的注册；动态添加的元素依旧绑定对应事件。
  - 阻止冒泡：
    - IE8之前，event.cancelBubble = true;
    - IE8之后，event.stopPropagation();
  - 阻止默认事件
    - IE8之前：event.returnValue = false;
    - IE8之后：event.preventDefault();



## 缓存：

- 浏览器缓存
  - cookie:
  
    由于http是无状态的，使用cookie使浏览器和服务器之间传递数据。
  
    缺点：每个http请求都带了cookie，使得首部内容增加，影响带宽；不适合存储私人敏感信息；大小限制4kb左右。
  
  - localStorage：
  
    本地存储永远不会过期，同源的本地存储还可以共享
  
  - sessionStorage:
    会话关闭了以后数据就自动清除
  
  - userData:
    持久化存储，关了浏览器也不会清除这些数据，但是可以设置失效时间，可以存储1MB数据。
- 强缓存：
  
  - 浏览器首次发送消息给服务器的时候，服务器返回的时候会加上Expire；服务器加上Cache-Control
- 协商缓存：
  - 浏览器首次发送消息给服务器的时候，服务器会在返回的报文中添加Last-Modified，浏览器再次发送消息的时候在请求头加上If-Modified-Since,服务器进行对比之后如果相同，则返回304
  - Etag, If Not Match



## 跨域：

- 跨域产生的原因是由于浏览器出于自身的安全考虑，他限制ajax请求的发送，DOM节点的获取，cookie的获取等必须要符合同源策略，所谓同源指的就是端口、域名、协议都一样，才会被认为同源

- 跨域的解决方法大概有cors,jsonp,代理这几种
  - jsonp：原理就是依赖script标签之间的传递没有同源策略的限制；前端动态创建一个script标签，src中定义一个回调函数，在后端获取到回调函数后，将数据包裹在回调函数中传回
  - cors：原理就是在后端设置Access-Control-Allow-Origin来使得浏览器支持跨域的数据响应。
  - 代理：webpack中设置proxytable，设置代理，利用的是服务器之间的传递也没有同源策略的限制。
  
- ws

  ```
  var ws = new WebSocket(url)
  ws.onopen = function(){
    ws.send(message)
  }
  ws.onclose = function(event){
    event.code
    event.reason
  }
  ws.onmessage = function(event){
    event.data
  }
  ```