一面：

#### TCP与UDP区别（√）

- TCP面向连接；UDP是无连接的，即发送数据之前不需要建立连接

- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；

  UDP尽最大努力交付，不保证可靠交付；

  Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

- UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

- 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。

- TCP对系统资源要求较多，UDP对系统资源要求较少。

  

#### HTTP组成部分，你能想起来哪些字段



#### 死锁及其原因解决办法，其他锁（√）

<https://blog.csdn.net/guaiguaihenguai/article/details/80303835>

<https://www.cnblogs.com/sunnyCx/p/8108687.html>

**概念：**指一个资源被多次调用，而多次调用方都未能释放该资源就会造成一种互相等待的现象，若无外力作用，它们都将无法推进下去。

**原因：**系统资源有限、进程推进顺序不合理。

**四个必要条件：**

- **互斥：**一个资源每次只能被一个进程使用。
- **占有且等待：**一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- **不可抢占：**进程已获得的资源，在末使用完之前，不能强行剥夺，只能在进程使用完时由自己释放。
- **循环等待：**若干进程之间形成一种头尾相接的循环等待资源关系。

**解决办法：**

（1）预防

1. 破坏“占有且等待”条件：

   每个进程在运行前必须一次性的申请它所要求的全部资源，且仅当该进程所要的资源均可满足时才一次性的分配。

2. 破坏“不可抢占”条件：

   根据进程的不同优先级，通过操作系统抢占这一资源

3. 破坏“循环等待”条件：

   定义资源类型的线性顺序，把资源中所有的资源编号，进程在申请资源时，必须严格按照资源编号的递增次序进行，否则操作系统不予分配。

（2）避免

1. 如果一个进程的请求会导致死锁，则不启动该进程
2. 如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。

**其他锁：**

同步锁：进程或者线程A和B一块配合，A执行到一定程序时需要依赖B的某个结果，于是停下来，示意B运行；B执行，再将结果给A；A再继续操作。

互斥锁：互斥锁为资源引入一个状态：锁定/非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。



#### 事件流，阻止冒泡的方法，IE

<https://www.jb51.net/article/94394.htm>

- 事件流包括三个阶段：事件捕获。处于目标。事件冒泡。
- 为DOM绑定事件之后，当用户触发到某元素的事件之时，则会从document开始一级一级的向下查找到对应的元素，该阶段为捕获阶段；到达目标之后则为目标阶段；触发目标的处理程序之后，则从目标一级一级的向上直到document，这个阶段为冒泡阶段。
- 一般都是使用冒泡事件流来进行事件的处理；
  - 事件冒泡的作用主要是允许多个操作被集中处理，例如一个列表的每一个字段点击都会出现相应的处理反应，则可以直接为所有字段的上一级元素绑定处理程序；
  - 但是有些程序相反需要取消冒泡机制带来的弊端，此时可以使用阻止事件冒泡的方法，
- js事件机制包括：事件绑定、事件监听、事件委托。
  - 事件绑定：
    - DOM元素绑定
    - js绑定
  - 事件监听：
    - W3C： element.addEventListener(event, function, useCapture);
    - element.attachEvent (event，function); 冒泡阶段执行
  - 事件委托：
    - 原理：利用冒泡，在所有需要绑定相同事件的子元素的父元素上绑定对应事件。
    - 优点：提高性能，减少事件的注册；动态添加的元素依旧绑定对应事件。
  - 阻止冒泡：
    - IE8之前，event.cancelBubble = true;
    - IE8之后，event.stopPropagation();
  - 阻止默认事件
    -  IE8之前：event.returnValue = false;
    -  IE8之后：event.preventDefault();



#### this指向，var b = obj.fun;b()中this的指向









#### css优先级，important和内联谁优先级更高？被声明important的属性被覆盖会怎样（√）

CSS选择器

- important 10000
- style内联样式 1000
- id选择器 100
- class选择器 10
- 属性选择器 10
- 伪类选择器 10
- 标签选择器 1
- 伪元素选择器 1
- 通配符 0

不会被覆盖



#### 回流和重绘，什么时候会重绘但是不回流（√）

- 重绘是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘
- 回流是页面布局或者几何属性需要改变。

回流**必定**会发生重绘，重绘**不一定**会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。



#### 闭包,手写闭包





#### 算法题，去掉字符串中的 'b' 和 'ac' 结构。（√）

```
//字符串中删除ac和b
function delacb(str) {
  let strAr = str.split("");
  for (let i = 0; i < strAr.length; i++) {
    if (strAr[i] == "b") {
      strAr.splice(i, 1);
      if (i >= 1) {
        i--;
      }
    } else if (strAr[i] == "a" && strAr[i + 1] == "c") {
      strAr.splice(i, 2);
      if (i >= 1) {
        i--;
      }
    }
  }
  return strAr.join("");
}
```



#### Promise.all的实现原理（√）

简单来说就是把所有要执行的函数都放进一个数组里面，然后数组以次以**同步**的形式一个一个执行，执行结束后能够接着执行then里面的东西。

```
//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)
Promise.all = function(promises) {
  let arr = [];
  let i = 0;
  function processData(index, data) {
    arr[index] = data;
    i++;
    if (i == promises.length) {
      resolve(arr);
    }
  }
  return new Promise((resolve, reject) => {
    for (let i = 0; i < promises.length; i++) {
      promises[i].then(data => {
        processData(i, data);
      }, reject);
    }
  });
};
```



#### Array.prototype.reduce原理（√）

```
//reduce
if (typeof Array.prototype.reduce != "function") {
  Array.prototype.reduce = function(callback, initialValue) {
    var previous = initialValue,
      k = 0,
      length = this.length;
    if (typeof initialValue === "undefined") {
      previous = this[0];
      k = 1;
    }

    if (typeof callback === "function") {
      for (k; k < length; k++) {
        this.hasOwnProperty(k) &&
          (previous = callback(previous, this[k], k, this));
      }
    }
    return previous;
  };
}
```



#### Vue双向绑定原理，手写数据劫持

<https://www.cnblogs.com/tugenhua0707/p/10306793.html>

##### vue2

- vue的双向数据绑定依赖三个主要的功能模块：

  - 观察者：利用object.defineProperty的get方法来获取当前的数据值，当属性值变化的时候会触发set方法来通知订阅者
  - 订阅者：维护一个订阅者列表，在观察者和指令解析器之间传递消息，收到更新通知之后，触发指令解析器
  - 指令解析器：解析指令模板，对不同的指令模板做出对应的处理，比如v-model模板中可以添加对input事件的监听，v-on模板中添加对应事件的监听，{{}}数据模板则是将对应的数据属性添加到订阅者列表中

- 有了这三个模块之后，整个数据双向绑定的过程可以理解为这样的几个步骤：

  - 首先，在vue实例创建的时候，对跟组件的所有元素进行遍历解析，解析的过程中是生成虚拟文档节点进行解析的，解析的过程中对不同的指令模板做出对应的处理，同时将绑定的data中的属性值添加到订阅者列表中
  - 当数据变化的时候，会触发set方法，进而触发指令解析器，对节点的value值进行更新，从而更新视图
  - 当视图变化的时候，对应的事件会监听到，进而可以更新对应的数据值

  ```
  <!DOCTYPE html>
   <html>
      <head>
        <meta charset="utf-8">
        <title>标题</title>
      </head>
      <body>
        <input type="text" id="demo" />
        <div id="xxx">{{name}}</div>
  
        <script type="text/javascript">
          const obj = {};
          Object.defineProperty(obj, 'name', {
            set: function(value) {
              document.getElementById('xxx').innerHTML = value;
              document.getElementById('demo').value = value;
            }
          });
          document.querySelector('#demo').oninput = function(e) {
            obj.name = e.target.value;
          }
          obj.name = '';
        </script>
      </body>
  </html>
  ```

  

##### vue3

当我们使用数组的方法或改变数组的下标是不能重新触发 Object.defineProperty中的set()方法的，因此就做不到实时响应了。所以使用 Object.defineProperty 存在如下缺点：

1. 监听数组的方法不能触发Object.defineProperty方法中的set操作(如果要监听到的话，需要重新编写数组的方法)。
2. 必须遍历每个对象的每个属性，如果对象嵌套很深的话，需要使用递归调用。

因此vue3.xx中之后就改用Proxy来更好的解决如上面的问题。

**Proxy基本语法**

```
const obj = new Proxy(target, handler);
//参数说明如下：
target: 被代理对象。
handler:是一个对象，声明了代理target的一些操作。
obj: 是被代理完成之后返回的对象。
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>proxy</title>
</head>
<body>
    <h1>使用Proxy 和 Reflect 实现双向数据绑定</h1>
    <input type="text" id="input">
    <h2>您输入的内容是： <i id="txt"></i></h2>
    <script>
        //获取dom元素
        let oInput = document.getElementById("input");
        let oTxt = document.getElementById("txt");

        //初始化代理对象
        let obj = {};

        //给obj增加代理对象
        let newProxy = new Proxy(obj,{
            get: (target,key,recevier)=>{
                //console.log("get:"+ key)
                return Reflect.get(target,key,recevier);
            },
            set: (target,key,value,recevier)=>{
                //监听newProxy是否有新的变化
                if(key == "text"){
                    oTxt.innerHTML = value;
                }
                
                //将变化反射回原有对象
                return Reflect.set(target,key,value,recevier);
            }
        })

        //监听input输入事件
        oInput.addEventListener("keyup",(e)=>{
            //修改代理对象的值
            newProxy.text = e.target.value;
        })
    </script>
</body>
</html>
```









算法：

二叉树递归/非递归遍历：<https://www.jianshu.com/p/5e9ea25a1aae>